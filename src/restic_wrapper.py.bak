import os
import shlex
import subprocess
import json
import logging
import boto3
from abc import ABC, abstractmethod
from typing import Optional, Dict, List
from urllib.parse import urlparse, parse_qs
from packaging import version

RESTIC_COMMAND = "restic"
RESTIC_VERSION_COMMAND = f"{RESTIC_COMMAND} version --json"
RESTIC_MIN_VERSION = "0.18.0"
RESTIC_LOG_LEVEL_ENV_KEY = "RESTIC_LOG_LEVEL"

# Configure default logger
logger = logging.getLogger("restic")
logging.basicConfig(level=os.environ.get(RESTIC_LOG_LEVEL_ENV_KEY, "INFO").upper())

class ResticError(Exception):
    pass

class RepositoryError(ResticError):
    pass

class CommandExecutionError(ResticError):
    def __init__(self, message, stderr=None):
        super().__init__(message)
        self.stderr = stderr

class UnsupportedSchemeError(RepositoryError):
    pass

class ResticVersionError(ResticError):
    pass

class Repository(ABC):
    def __init__(self, location: str, password: Optional[str] = None):
        logger.info(f"Initializing repository at location: {location}")
        self.location = location
        self._explicit_password = password
        self._cached_env = None

    def restic_password(self) -> Optional[str]:
        return self._explicit_password or os.getenv("RESTIC_PASSWORD")

    def to_env(self) -> Dict[str, str]:
        if self._cached_env:
            return self._cached_env

        env = {}
        pwd = self.restic_password()
        if not pwd:
            raise RepositoryError("RESTIC_PASSWORD must be set explicitly or in the environment.")
        env["RESTIC_PASSWORD"] = pwd
        env.update(self.backend_env())
        logger.debug("Constructed environment for restic")
        self._cached_env = env
        return env

    @abstractmethod
    def backend_env(self) -> Dict[str, str]:
        pass

    @abstractmethod
    def validate(self):
        pass

    @classmethod
    def from_uri(cls, uri: str, password: Optional[str] = None) -> 'Repository':
        logger.info(f"Parsing repository URI: {cls.redact_sensitive_info(uri)}")
        parsed = urlparse(uri)
        scheme = parsed.scheme.lower()

        repo_classes = {
            's3': S3Repository,
            'b2': B2Repository,
            'local': LocalRepository,
            '': LocalRepository
        }

        if scheme not in repo_classes:
            raise UnsupportedSchemeError(f"Unsupported repository scheme: {scheme}") # Implement UnsupportedSchemeError

        repo_class = repo_classes[scheme]
        return repo_class.from_parsed_uri(parsed, password)

    @staticmethod
    def redact_sensitive_info(uri: str) -> str:
        parsed = urlparse(uri)
        redacted_netloc = f"{parsed.hostname}[:*****]" if parsed.username else parsed.netloc
        return parsed._replace(netloc=redacted_netloc).geturl()

class LocalRepository(Repository):
    @classmethod
    def from_parsed_uri(cls, parsed_uri, password: Optional[str] = None) -> 'LocalRepository':
        if hasattr(parsed_uri, "netloc") and parsed_uri.netloc:
            raise ValueError("parsed_uri must not have a 'netloc' attribute value for a local repository.")

        if not hasattr(parsed_uri, "path") or (hasattr(parsed_uri, "path") and not parsed_uri.path):
            raise ValueError("parsed_uri must have a 'path' attribute value set")

        # Generate the absolute path
        path = os.path.abspath(parsed_uri.path)

        # Return the initialized LocalRepository instance
        return cls(location=path, password=password)

    def backend_env(self) -> Dict[str, str]:
        return {}

    def validate(self):
        logger.info(f"Validating local repository path: {self.location}")
        try:
            if not os.path.isdir(self.location):
                raise RepositoryError(f"Local path does not exist: {self.location}")
        except OSError as e:
            raise RepositoryError(f"Error accessing local repository: {e}")

class S3Repository(Repository):
    def __init__(self, location: str, password: Optional[str] = None,
                 aws_access_key_id: Optional[str] = None,
                 aws_secret_access_key: Optional[str] = None,
                 aws_default_region: Optional[str] = None):
        super().__init__(location, password)
        self.aws_access_key_id = aws_access_key_id or os.getenv("AWS_ACCESS_KEY_ID")
        self.aws_secret_access_key = aws_secret_access_key or os.getenv("AWS_SECRET_ACCESS_KEY")
        self.aws_default_region = aws_default_region or os.getenv("AWS_DEFAULT_REGION")

    @classmethod
    def from_parsed_uri(cls, parsed_uri, password: Optional[str] = None) -> 'S3Repository':
        bucket = parsed_uri.netloc
        path = parsed_uri.path.lstrip('/')
        location = f"s3:{bucket}/{path}"
        query_params = parse_qs(parsed_uri.query)

        return cls(
            location=location,
            password=password,
            aws_access_key_id=query_params.get('access_key_id', [None])[0],
            aws_secret_access_key=query_params.get('secret_access_key', [None])[0],
            aws_default_region=query_params.get('region', [None])[0]
        )

    def backend_env(self) -> Dict[str, str]:
        env = {}
        missing_credentials = []
        if not self.aws_access_key_id:
            missing_credentials.append("AWS_ACCESS_KEY_ID")
        if not self.aws_secret_access_key:
            missing_credentials.append("AWS_SECRET_ACCESS_KEY")
        if missing_credentials:
            raise RepositoryError(f"AWS credentials must be set explicitly or in the environment. Missing: {', '.join(missing_credentials)}")
        env["AWS_ACCESS_KEY_ID"] = self.aws_access_key_id
        env["AWS_SECRET_ACCESS_KEY"] = self.aws_secret_access_key
        if self.aws_default_region:
            env["AWS_DEFAULT_REGION"] = self.aws_default_region
        return env

    def validate(self):
        logger.info("Validating S3 repository configuration")
        try:
            s3 = boto3.client('s3')
            bucket_name = self.location.split(':')[1].split('/')[0]
            s3.head_bucket(Bucket=bucket_name)
            logger.info(f"Successfully validated S3 bucket: {bucket_name}")
        except ImportError:
            logger.warning("boto3 is not installed. S3 repository validation skipped.")
        except Exception as e:
            raise RepositoryError(f"Failed to validate S3 repository: {str(e)}")

class B2Repository(Repository):
    def __init__(self, location: str, password: Optional[str] = None,
                 b2_account_id: Optional[str] = None,
                 b2_account_key: Optional[str] = None):
        super().__init__(location, password)
        self.b2_account_id = b2_account_id or os.getenv("B2_ACCOUNT_ID")
        self.b2_account_key = b2_account_key or os.getenv("B2_ACCOUNT_KEY")

    @classmethod
    def from_parsed_uri(cls, parsed_uri, password: Optional[str] = None) -> 'B2Repository':
        bucket = parsed_uri.netloc
        path = parsed_uri.path.lstrip('/')
        location = f"b2:{bucket}/{path}"
        query_params = parse_qs(parsed_uri.query)

        return cls(
            location=location,
            password=password,
            b2_account_id=query_params.get('account_id', [None])[0],
            b2_account_key=query_params.get('account_key', [None])[0]
        )

    def backend_env(self) -> Dict[str, str]:
        env = {}
        missing_credentials = []
        if not self.b2_account_id:
            missing_credentials.append("B2_ACCOUNT_ID")
        if not self.b2_account_key:
            missing_credentials.append("B2_ACCOUNT_KEY")
        if missing_credentials:
            raise RepositoryError(f"B2 credentials must be set explicitly or in the environment. Missing: {', '.join(missing_credentials)}")
        env["B2_ACCOUNT_ID"] = self.b2_account_id
        env["B2_ACCOUNT_KEY"] = self.b2_account_key
        return env

    def validate(self):
        logger.info("Validating B2 repository configuration")
        if not self.b2_account_id or not self.b2_account_key:
            raise RepositoryError("B2 credentials are missing or incomplete.")
        # TODO: Implement B2 API call to verify credentials and bucket access

class Selection:
    def __init__(self, paths: Optional[List[str]] = None):
        self.paths = paths or []

    def add_path(self, path: str):
        if path not in self.paths:
            self.paths.append(path)

    def remove_path(self, path: str):
        if path in self.paths:
            self.paths.remove(path)

    def __iter__(self):
        return iter(self.paths)

    def __repr__(self):
        return f"<Selection paths={self.paths}>"

class Exclusion:
    def __init__(self, patterns: Optional[List[str]] = None):
        self.patterns = patterns or []

    def add_pattern(self, pattern: str):
        if pattern not in self.patterns:
            self.patterns.append(pattern)

    def remove_pattern(self, pattern: str):
        if pattern in self.patterns:
            self.patterns.remove(pattern)

    def __iter__(self):
        return iter(self.patterns)

    def __repr__(self):
        return f"<Exclusion patterns={self.patterns}>"

class BackupTarget:
    def __init__(self, selection: Selection, tags: Optional[List[str]] = None, exclusion: Optional[Exclusion] = None):
        self.selection = selection
        self.tags = tags or []
        self.exclusion = exclusion or Exclusion()

class ResticClient:
    def __init__(self, repo: Repository, min_version: str = RESTIC_MIN_VERSION):
        logger.info("Initializing ResticClient...")
        self.repo = repo
        self.repo.validate()
        self.restic_version = self._verify_restic_executable(min_version)
        logger.info(f"Detected Restic version: {self.restic_version}")

    def _verify_restic_executable(self, min_version: str) -> str | None:
        try:
            logger.info("Verifying restic executable...")

            restic_command = shlex.split(RESTIC_VERSION_COMMAND)
            subprocess_result = subprocess.run(
                restic_command,
                check=True,
                capture_output=True,
                text=True
            )
            restic_version = subprocess_result.stdout

            if version.parse(restic_version) < version.parse(min_version):
                raise ResticError(f"Restic version {restic_version} is below the required minimum version {min_version}.")

            return restic_version
        except FileNotFoundError:
            raise ResticError("Restic executable not found. Please ensure it is installed and in the PATH.")

    def _run_restic_command(self, command: List[str]) -> Dict:
        supported = {"backup", "snapshots", "forget", "restore", "prune", "init", "check"}
        json_producing_commands = {"backup", "snapshots", "forget", "restore"}
        if command[0] in supported and command[0] in json_producing_commands:
            command.append("--json")
        full_command = ["restic"] + command
        logger.info(f"Executing command: {' '.join(full_command)}")
        try:
            result = subprocess.run(
                full_command,
                check=True,
                capture_output=True,
                text=True,
                env=self.repo.to_env()
            )
            logger.debug("Command output: %s", result.stdout)
            return json.loads(result.stdout) if command[0] in json_producing_commands else {"output": result.stdout}
        except subprocess.CalledProcessError as e:
            logger.error("Command error output: %s", e.stderr)
            raise CommandExecutionError(f"Command failed: {' '.join(command)}", stderr=e.stderr.strip())
